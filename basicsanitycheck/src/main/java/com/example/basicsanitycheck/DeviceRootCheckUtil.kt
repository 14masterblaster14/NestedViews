package com.example.basicsanitycheck

import android.content.Context
import android.util.Log
import java.io.BufferedReader
import java.io.File
import java.io.IOException
import java.io.InputStreamReader


/**
 *
 *  Check whether device is rooted or not < Prefered Way --> Use of Google SafetyNet API >
 *
 *  A simple root checker that gives an *indication* if the device is rooted or not.
 *
 *  Disclaimer: **root==god**, so there's no 100% way to check for root.
 *
 *  Refer : https://github.com/scottyab/rootbeer/blob/master/rootbeerlib/src/main/java/com/scottyab/rootbeer/RootBeer.java
 */


object DeviceRootCheckUtil {

    private var result = false

    private val knownRootAppsPackages = arrayListOf("com.noshufou.android.su",
            "com.noshufou.android.su.elite",
            "eu.chainfire.supersu",
            "com.koushikdutta.superuser",
            "com.thirdparty.superuser",
            "com.yellowes.su",
            "com.topjohnwu.magisk")

    private val knownDangerousAppsPackages = arrayListOf("com.koushikdutta.rommanager",
            "com.koushikdutta.rommanager.license",
            "com.dimonvideo.luckypatcher",
            "com.chelpus.lackypatch",
            "com.ramdroid.appquarantine",
            "com.ramdroid.appquarantinepro",
            "com.android.vending.billing.InAppBillingService.COIN",
            "com.chelpus.luckypatcher")

    private val suPaths = arrayListOf("/data/local/",
            "/data/local/bin/",
            "/data/local/xbin/",
            "/data/local/",
            "/sbin/",
            "/su/bin/",
            "/system/bin/",
            "/system/bin/.ext/",
            "/system/bin/failsafe/",
            "/system/sd/xbin/",
            "/system/usr/we-need-root/",
            "/system/xbin/",
            "/cache",
            "/data",
            "/dev")


    //  Returns true if device is rooted otherwise false

    fun isDeviceRooted(context: Context): Boolean {


        result = (detectTestKeys() || detectRootManagementApps(context) || detectPotentiallyDangerousApps(context)
                || checkForBinary("su") || checkSuExists() || checkSuperUser())

        Log.i("MasterBlaster", "Final Device Root Check Result : ${result}")
        return result


    }


    // #1. Check the Build Information whether it's a test build or not
    /**
     * Release-Keys and Test-Keys has to do with how the kernel is signed when it is compiled.
     * Test-Keys means it was signed with a custom key generated by a third-party developer.
     * @return true if signed with Test-keys
     */

    private fun detectTestKeys(): Boolean {

        val buildTags = android.os.Build.TAGS
        if (buildTags != null && buildTags.contains("test-keys")) {

            Log.i("MasterBlaster", "Test Keys detected!!")
            return true
        }
        return false
    }


    /**
     * Using the PackageManager, check for a list of well known root apps. @link {Const.knownRootAppsPackages}
     * @param additionalRootManagementApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */

    private fun detectRootManagementApps(context: Context): Boolean {

        return isAnyPackageFromListInstalled(context, knownRootAppsPackages)
    }


    /**
     * Using the PackageManager, check for a list of well known apps that require root. @link {Const.knownRootAppsPackages}
     * @param additionalDangerousApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */

    private fun detectPotentiallyDangerousApps(context: Context): Boolean {

        return isAnyPackageFromListInstalled(context, knownDangerousAppsPackages)
    }


    /**
     *
     * @param filename - check for this existence of the file
     * @return true if found
     */

    private fun checkForBinary(fileName: String): Boolean {

        try {
            for (path in suPaths) {

                val file = File(path, fileName)

                if (file.exists()) {
                    Log.i("MasterBlaster", "Binary Detected! at :-> ${path + fileName}")
                    return true
                }
            }
        } catch (exception: Exception) {
            Log.i("MasterBlaster", "Got exception in device root checking <SU> : ${exception}")
        }

        return false

    }


    /**
     * A variation on the checking for SU, this attempts a 'which su'
     * @return true if su found
     */

    private fun checkSuExists(): Boolean {

        var process: Process? = null
        var input: BufferedReader? = null

        try {

            process = Runtime.getRuntime().exec(arrayOf("which", "su"))
            input = BufferedReader(InputStreamReader(process.inputStream))
            return input.readLine() != null

        } catch (e: Exception) {

            return false

        } finally {

            if (process != null) process.destroy()

            if (input != null) {

                try {

                    input.close()

                } catch (e: IOException) {

                    Log.i("MasterBlaster", "IO Exception in closing the file :-> ${e.message}")
                    e.printStackTrace()
                }
            }
        }
    }

    // #2. Check if /system/app/Superuser.apk is present
    private fun checkSuperUser(): Boolean {

        try {
            val file = File("/system/app/Superuser.apk")

            if (file.exists()) {

                return true
            }
        } catch (exception: Exception) {

            Log.i("MasterBlaster", "Got exception in device root checking <Superuser> : ${exception}")
        }

        return false
    }


    private fun isAnyPackageFromListInstalled(context: Context, packageList: ArrayList<String>): Boolean {

        val packageManager = context.packageManager

        for (packageName in packageList) {

            try {
                // Root app detected
                packageManager.getPackageInfo(packageName, 0)
                Log.i("MasterBlaster", "Root Management App detected! :-> ${packageName}")

                return true

            } catch (e: Exception) {
                // Exception thrown, package is not installed into the system
            }
        }

        return false
    }
}